import os
import uuid
import base64
from pathlib import Path
from typing import Optional

from dotenv import load_dotenv
from fastapi import FastAPI, Request, Form, UploadFile, File, HTTPException
from fastapi.responses import HTMLResponse, FileResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from jinja2 import Environment, FileSystemLoader, select_autoescape
from openai import OpenAI

load_dotenv()

API_KEY = os.getenv("OPENAI_API_KEY")
if not API_KEY:
    raise RuntimeError("Defina OPENAI_API_KEY nas vari√°veis de ambiente do Render (n√£o no GitHub).")

client = OpenAI(api_key=API_KEY)

BASE_DIR = Path(__file__).parent
MEDIA_DIR = BASE_DIR / "media"
MEDIA_DIR.mkdir(exist_ok=True)

TEMPLATES_DIR = BASE_DIR / "templates"
env = Environment(
    loader=FileSystemLoader(str(TEMPLATES_DIR)),
    autoescape=select_autoescape(["html", "xml"])
)

app = FastAPI(title="Ultra Real AI - Personagem + Imagens + V√≠deos")

app.mount("/media", StaticFiles(directory=str(MEDIA_DIR)), name="media")


# -----------------------------
# Utilit√°rios
# -----------------------------
def save_b64_image_to_file(b64_json: str, out_path: Path) -> None:
    raw = base64.b64decode(b64_json)
    out_path.write_bytes(raw)

def id_file(ext: str) -> str:
    return f"{uuid.uuid4().hex}{ext}"

def ultra_real_prompt(base: str) -> str:
    # Observa√ß√£o: ‚Äúporos e rugas‚Äù √© totalmente permitido.
    # S√≥ evite pedir para copiar rosto de pessoa real famosa/terceiro.
    return (
        base.strip()
        + "\n\nEstilo: fotografia hiper-realista, pele real com poros vis√≠veis, microtextura, sinais de express√£o sutis, "
          "ilumina√ß√£o natural, lente 85mm, profundidade de campo suave, alta nitidez no rosto, cores naturais."
    )

def safe_read_upload(file: UploadFile) -> bytes:
    content = file.file.read()
    if not content:
        raise HTTPException(400, "Arquivo vazio.")
    return content


# -----------------------------
# ‚ÄúBanco‚Äù simples (arquivo)
# -----------------------------
# Para demo: guardamos um arquivo TXT por personagem com o caminho da imagem de refer√™ncia.
# Em produ√ß√£o: use SQLite ou Postgres.
def character_ref_path(character_id: str) -> Path:
    return MEDIA_DIR / f"{character_id}.ref.txt"

def set_character_ref(character_id: str, ref_image_filename: str) -> None:
    character_ref_path(character_id).write_text(ref_image_filename, encoding="utf-8")

def get_character_ref(character_id: str) -> Optional[str]:
    p = character_ref_path(character_id)
    if not p.exists():
        return None
    return p.read_text(encoding="utf-8").strip() or None


# -----------------------------
# UI
# -----------------------------
@app.get("/", response_class=HTMLResponse)
def home(request: Request):
    tpl = env.get_template("index.html")

    # Lista imagens e v√≠deos gerados
    items = sorted([p.name for p in MEDIA_DIR.glob("*") if p.suffix.lower() in {".png", ".jpg", ".jpeg", ".mp4"}])
    return tpl.render(items=items)


# -----------------------------
# 1) Criar personagem (imagem-base)
# -----------------------------
@app.post("/api/character/create")
def create_character(
    description: str = Form(...),
    size: str = Form("1024x1024"),
):
    """
    Cria um personagem IA (imagem base) e gera um character_id.
    """
    character_id = uuid.uuid4().hex

    prompt = ultra_real_prompt(
        f"Crie um retrato ultra realista de um personagem original (n√£o baseado em pessoa real). {description}"
    )

    # Gera√ß√£o de imagem (b64_json)
    result = client.images.generate(
        model="gpt-image-1",
        prompt=prompt,
        size=size
    )

    b64_json = result.data[0].b64_json
    filename = id_file(".png")
    out_path = MEDIA_DIR / filename
    save_b64_image_to_file(b64_json, out_path)

    # Define essa imagem como refer√™ncia do personagem
    set_character_ref(character_id, filename)

    return {
        "character_id": character_id,
        "ref_image": f"/media/{filename}",
        "download": f"/api/download/{filename}"
    }


# -----------------------------
# 2) Gerar nova imagem mantendo o mesmo rosto
# -----------------------------
@app.post("/api/character/{character_id}/image")
def generate_image_same_face(
    character_id: str,
    scene: str = Form(...),
    size: str = Form("1024x1024"),
):
    """
    Gera uma nova imagem usando a imagem do personagem como refer√™ncia (image-to-image).
    Isso √© o que ajuda a manter o mesmo rosto.
    """
    ref_filename = get_character_ref(character_id)
    if not ref_filename:
        raise HTTPException(404, "Personagem n√£o encontrado. Crie o personagem primeiro.")

    ref_path = MEDIA_DIR / ref_filename
    if not ref_path.exists():
        raise HTTPException(500, "Refer√™ncia do personagem n√£o encontrada no servidor.")

    prompt = ultra_real_prompt(
        "Use a imagem fornecida como refer√™ncia do mesmo personagem (mesmo rosto). "
        f"Crie esta nova cena: {scene}. "
        "Mantenha identidade facial consistente (mesmo formato do rosto, olhos, nariz e boca), "
        "mas permita mudan√ßas de roupa, pose e ambiente."
    )

    # Tenta image-to-image (edits). Se o modelo/conta n√£o suportar, cai para text-only (menos consistente).
    try:
        with open(ref_path, "rb") as img:
            result = client.images.edit(
                model="gpt-image-1",
                image=img,
                prompt=prompt,
                size=size
            )
        b64_json = result.data[0].b64_json
        method = "reference-image"
    except Exception:
        # fallback (pode variar mais o rosto)
        result = client.images.generate(
            model="gpt-image-1",
            prompt=prompt,
            size=size
        )
        b64_json = result.data[0].b64_json
        method = "text-fallback"

    filename = id_file(".png")
    out_path = MEDIA_DIR / filename
    save_b64_image_to_file(b64_json, out_path)

    return {
        "character_id": character_id,
        "method": method,
        "image": f"/media/{filename}",
        "download": f"/api/download/{filename}"
    }


# -----------------------------
# 3) Gerar v√≠deo com o mesmo rosto (rota pronta)
# -----------------------------
@app.post("/api/character/{character_id}/video")
def generate_video_same_face(
    character_id: str,
    prompt: str = Form(...),
):
    """
    V√≠deo depende de acesso ao endpoint de v√≠deo na sua conta.
    Mantemos a rota pronta. Se sua conta n√£o tiver, retorna erro explicando.
    """
    ref_filename = get_character_ref(character_id)
    if not ref_filename:
        raise HTTPException(404, "Personagem n√£o encontrado. Crie o personagem primeiro.")

    ref_path = MEDIA_DIR / ref_filename
    if not ref_path.exists():
        raise HTTPException(500, "Refer√™ncia do personagem n√£o encontrada no servidor.")

    # IMPORTANTE:
    # Dependendo do acesso da sua conta, o endpoint e assinatura podem mudar.
    # Por isso fazemos um try e damos uma mensagem clara.
    try:
        # Exemplo conceitual: usar a imagem como primeiro frame / refer√™ncia.
        # Se sua conta suportar, adapte este trecho conforme o modelo/endpoints dispon√≠veis.
        # (Se n√£o suportar, d√° exce√ß√£o e a gente explica.)
        with open(ref_path, "rb") as img:
            video_job = client.videos.generate(  # pode n√£o existir na sua SDK/conta
                model="sora",
                prompt=prompt,
                image=img
            )

        # Se retornar um URL/bytes, voc√™ salva em .mp4 dentro de /media.
        # Como isso varia por conta/modelo, deixamos a mensagem.
        return {"status": "ok", "detail": "V√≠deo iniciado. (Ajuste o download conforme retorno do seu endpoint)."}
    except Exception as e:
        raise HTTPException(
            501,
            "Sua conta/SDK ainda n√£o tem o endpoint de v√≠deo configurado aqui. "
            "O app j√° est√° pronto para imagens com rosto consistente. "
            "Se voc√™ quiser, eu adapto esta rota para o provedor de v√≠deo que voc√™ escolher (ou para o endpoint de v√≠deo que sua conta tiver). "
            f"Erro t√©cnico: {type(e).__name__}"
        )


# -----------------------------
# Downloads
# -----------------------------
@app.get("/api/download/{filename}")
def download_file(filename: str):
    path = MEDIA_DIR / filename
    if not path.exists():
        raise HTTPException(404, "Arquivo n√£o encontrado.")
    return FileResponse(path, filename=filename)
<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ultra Real AI</title>
  <style>
    body{font-family:Arial, sans-serif; max-width:960px; margin:0 auto; padding:24px;}
    .box{border:1px solid #ddd; border-radius:12px; padding:16px; margin:12px 0;}
    input, textarea, button, select{width:100%; padding:10px; margin:8px 0; border-radius:10px; border:1px solid #ccc;}
    button{cursor:pointer; font-weight:bold;}
    .grid{display:grid; grid-template-columns:repeat(2,1fr); gap:12px;}
    .item{border:1px solid #eee; border-radius:12px; padding:10px;}
    img, video{width:100%; border-radius:12px;}
    .row{display:flex; gap:10px;}
    .row > *{flex:1;}
    .small{font-size:12px; color:#666;}
    .ok{color:#0a7;}
    .warn{color:#c60;}
  </style>
</head>
<body>
  <h1>üî• Ultra Real AI</h1>
  <p class="small">
    Fluxo: 1) Crie um personagem (rosto fixo) ‚Üí 2) Gere novas imagens mantendo o rosto ‚Üí 3) (Opcional) V√≠deo.
  </p>

  <div class="box">
    <h2>1) Criar personagem (ultra-realista)</h2>
    <form id="createCharacterForm">
      <textarea name="description" rows="3" placeholder="Descreva o personagem (ex.: mulher 28 anos, pele oliva com sardas sutis, cabelo castanho ondulado, estilo wellness, express√£o confiante)"></textarea>
      <div class="row">
        <select name="size">
          <option value="1024x1024">1024x1024</option>
          <option value="1536x1024">1536x1024</option>
          <option value="1024x1536">1024x1536</option>
        </select>
        <button type="submit">Criar personagem</button>
      </div>
    </form>
    <div id="createResult"></div>
  </div>

  <div class="box">
    <h2>2) Nova imagem com o MESMO rosto</h2>
    <form id="newImageForm">
      <input name="character_id" placeholder="Cole aqui o character_id do personagem" />
      <textarea name="scene" rows="3" placeholder="Descreva a nova cena (ex.: em um escrit√≥rio moderno, luz do fim da tarde, roupa social, olhando para a c√¢mera)"></textarea>
      <div class="row">
        <select name="size">
          <option value="1024x1024">1024x1024</option>
          <option value="1536x1024">1536x1024</option>
          <option value="1024x1536">1024x1536</option>
        </select>
        <button type="submit">Gerar nova imagem</button>
      </div>
      <p class="small warn">Dica: consist√™ncia m√°xima acontece quando a rota usa a imagem como refer√™ncia (image-to-image).</p>
    </form>
    <div id="imageResult"></div>
  </div>

  <div class="box">
    <h2>3) V√≠deo com o MESMO rosto (opcional)</h2>
    <form id="videoForm">
      <input name="character_id" placeholder="character_id" />
      <textarea name="prompt" rows="3" placeholder="Prompt do v√≠deo (ex.: c√¢mera se aproxima, sorriso sutil, movimento natural, ilumina√ß√£o realista)"></textarea>
      <button type="submit">Gerar v√≠deo</button>
      <p class="small warn">
        Se sua conta n√£o tiver endpoint de v√≠deo habilitado, esta rota vai avisar. Eu te ajudo a ativar ou integrar outro provedor.
      </p>
    </form>
    <div id="videoResult"></div>
  </div>

  <div class="box">
    <h2>Galeria (arquivos gerados)</h2>
    <div class="grid">
      {% for item in items %}
        <div class="item">
          <div class="small">{{ item }}</div>
          {% if item.endswith(".mp4") %}
            <video controls src="/media/{{ item }}"></video>
          {% else %}
            <img src="/media/{{ item }}" />
          {% endif %}
          <a href="/api/download/{{ item }}"><button>Baixar</button></a>
        </div>
      {% endfor %}
    </div>
  </div>

<script>
async function postForm(url, formEl){
  const fd = new FormData(formEl);
  const res = await fetch(url, { method:"POST", body: fd });
  const data = await res.json();
  if(!res.ok) throw data;
  return data;
}

document.getElementById("createCharacterForm").addEventListener("submit", async (e)=>{
  e.preventDefault();
  const out = document.getElementById("createResult");
  out.innerHTML = "Gerando...";
  try{
    const data = await postForm("/api/character/create", e.target);
    out.innerHTML = `
      <p class="ok"><b>Personagem criado!</b></p>
      <p><b>character_id:</b> <code>${data.character_id}</code></p>
      <img src="${data.ref_image}" style="max-width:420px;border-radius:12px" />
      <p><a href="${data.download}">Baixar imagem</a></p>
    `;
  }catch(err){
    out.innerHTML = `<pre>${JSON.stringify(err,null,2)}</pre>`;
  }
});

document.getElementById("newImageForm").addEventListener("submit", async (e)=>{
  e.preventDefault();
  const out = document.getElementById("imageResult");
  out.innerHTML = "Gerando...";
  try{
    const cid = e.target.character_id.value.trim();
    const data = await postForm(`/api/character/${cid}/image`, e.target);
    out.innerHTML = `
      <p class="ok"><b>Imagem gerada!</b> (m√©todo: ${data.method})</p>
      <img src="${data.image}" style="max-width:420px;border-radius:12px" />
      <p><a href="${data.download}">Baixar imagem</a></p>
    `;
  }catch(err){
    out.innerHTML = `<pre>${JSON.stringify(err,null,2)}</pre>`;
  }
});

document.getElementById("videoForm").addEventListener("submit", async (e)=>{
  e.preventDefault();
  const out = document.getElementById("videoResult");
  out.innerHTML = "Enviando...";
  try{
    const cid = e.target.character_id.value.trim();
    const data = await postForm(`/api/character/${cid}/video`, e.target);
    out.innerHTML = `<pre>${JSON.stringify(data,null,2)}</pre>`;
  }catch(err){
    out.innerHTML = `<pre>${JSON.stringify(err,null,2)}</pre>`;
  }
});
</script>
</body>
</html>